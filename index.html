<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JamSnap - Auto Loop</title>
    <meta name="theme-color" content="#1a1a2e">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="icon" href="favicon.png" type="image/png">
    <link rel="apple-touch-icon" href="logo-192.png">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.3/build/vexflow-min.js"></script>

    <style>
        :root {
            --bg-color: #1a1a2e;
            --neon-green: #00ff9d;
            --neon-pink: #ff00cc;
            --neon-blue: #00f3ff;
            --neon-purple: #bd00ff;
        }

        .hidden { display: none !important; }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Nunito', sans-serif;
            margin: 0; padding: 0;
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
            font-size: 17px;
        }

        /* Main app shell must flex to let grid fill remaining space */
        #appShell {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            padding-bottom: 180px; /* leave space for bottom tabs + drawer */
            padding-top: 78px; /* leave space for fixed header, tighter gap */
        }

        /* SHEET STATUS */
        .sheet-status {
            position: fixed;
            top: 10px; right: 10px;
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--neon-blue);
            padding: 6px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            z-index: 20;
            display: flex; align-items: center; gap: 8px;
        }
        .sheet-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--neon-blue);
            box-shadow: 0 0 6px var(--neon-blue);
        }
        .sheet-status.error .sheet-dot { background: #ff6b6b; box-shadow: 0 0 8px #ff6b6b; }
        .sheet-status.ready .sheet-dot { background: var(--neon-green); box-shadow: 0 0 8px var(--neon-green); }

        .hidden { display: none !important; }

        /* APP HEADER */
        .app-header {
            position: fixed;
            top: 10px; left: 10px; right: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.35);
            border: 1px solid #2f3a5a;
            padding: 8px 12px;
            border-radius: 12px;
            z-index: 22;
        }
        .logo-badge {
            width: 42px; height: 42px;
            border-radius: 12px;
            background: url('logo-192.png') center center / cover no-repeat, #111;
            display: inline-block;
            box-shadow: 0 0 10px rgba(189,0,255,0.35);
            flex-shrink: 0;
            text-indent: -9999px;
        }
        .header-email {
            flex: 1;
            font-weight: 700;
            color: #e7ecff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .header-auth-btn {
            background: var(--neon-blue);
            color: #000;
            border: none;
            border-radius: 10px;
            padding: 8px 10px;
            font-weight: 800;
            cursor: pointer;
        }
        /* Hide top bar auth buttons; account handled in modal */
        .auth-status button { display: none; }

        /* FULL PAGE AUTH GATE */
        .auth-gate {
            position: fixed; inset: 0;
            background: radial-gradient(circle at 20% 20%, #1f2c4f, #0a0a1a 55%);
            display: flex; align-items: center; justify-content: center;
            z-index: 300;
            padding: 20px;
        }
        .auth-gate-card {
            width: 360px; max-width: 95%;
            background: #111526;
            border: 1px solid #2a2f4d;
            border-radius: 18px;
            padding: 20px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.55);
        }
        .auth-gate-card h2 {
            margin: 0 0 12px 0;
            font-family: 'Fredoka One', cursive;
            letter-spacing: 0.4px;
        }
        .auth-gate-card label {
            display: block;
            font-size: 0.9rem;
            color: #cfd5ff;
            margin-top: 10px;
        }

        .fancy-select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid #2f3a5a;
            background: linear-gradient(135deg, #1a223b, #0f162b);
            color: #e7ecff;
            font-weight: 700;
            box-shadow: 0 0 12px rgba(0,243,255,0.2);
        }
        .auth-gate-card input {
            width: 100%;
            margin-top: 6px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #2f3a5a;
            background: #0a0f1f;
            color: #fff;
        }
        .auth-gate-actions {
            display: flex; gap: 10px; margin-top: 16px;
        }
        .auth-gate button {
            flex: 1;
            padding: 12px 0;
            border: none;
            border-radius: 10px;
            font-weight: 800;
            cursor: pointer;
        }
        .auth-gate .primary { background: var(--neon-green); color: #0a0a1a; }
        .auth-gate .secondary { background: #1d243b; color: #d8e0ff; border: 1px solid #2f3a5a; }
        .auth-gate .link-row {
            margin-top: 12px; display: flex; justify-content: space-between; color: #7ea7ff; font-size: 0.9rem; cursor: pointer;
        }

        /* ACTIONS STACK */
        .actions-stack {
            margin-top: 70px;
            padding: 0 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
            z-index: 12;
        }

        /* ACTIONS STACK */
        .sheet-actions {
            display: flex; gap: 8px; align-items: center;
            background: rgba(0,0,0,0.4);
            border: 1px solid #333;
            padding: 8px 10px;
            border-radius: 12px;
            z-index: 12;
            flex-wrap: wrap;
        }
        .sheet-actions input {
            flex: 1;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #444;
            background: #111;
            color: #fff;
        }
        .sheet-actions button {
            background: var(--neon-blue);
            color: #000;
            border: none;
            border-radius: 10px;
            padding: 8px 10px;
            font-weight: 700;
            cursor: pointer;
        }
        .sheet-actions button.secondary {
            background: #333;
            color: #fff;
            border: 1px solid #555;
        }

        .tempo-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 10px 0 10px;
        }
        .tempo-pill {
            padding: 8px 12px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid #2f3a5a;
            font-weight: 800;
            color: #e7ecff;
        }
        .tempo-btn {
            background: var(--neon-blue);
            color: #000;
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(0,243,255,0.35);
        }

        /* TIMELINE */
        .timeline-container {
            padding: 20px 15px 5px 15px;
            background: linear-gradient(180deg, #101018 0%, var(--bg-color) 100%);
            position: relative;
            width: 100%;
            margin: 0 auto;
        }
        .time-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: #cfe8ff;
            margin-top: 12px;
        }
        .time-row .time-label {
            font-weight: 700;
            letter-spacing: 0.3px;
        }
        .controls-disabled {
            opacity: 0.35;
            pointer-events: none;
        }
        #audioPlayer { display: none; }

        input[type=range] {
            -webkit-appearance: none; appearance: none; width: calc(100% - 20px); background: transparent; position: relative; z-index: 5; display: block; margin: 0 10px;
        }
        input[type=range]:focus { outline: none; }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 10px; cursor: pointer;
            background: #333; border-radius: 25px;
            border: 2px solid var(--neon-blue);
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 32px; width: 32px; margin-top: -10px;
            background: linear-gradient(135deg, #5cf0ff, #12ffa1);
            border: 3px solid #0b2030;
            border-radius: 12px;
            box-shadow: 0 0 8px rgba(18,255,161,0.45), 0 0 4px rgba(0,0,0,0.35);
            cursor: pointer;
            transition: transform 0.12s, box-shadow 0.12s;
        }
        input[type=range]::-webkit-slider-thumb:active { transform: translateY(-1px) scale(1.05); box-shadow: 0 0 10px rgba(18,255,161,0.6); }
        input[type=range]::-moz-range-thumb {
            height: 32px; width: 32px;
            background: linear-gradient(135deg, #5cf0ff, #12ffa1);
            border: 3px solid #0b2030;
            border-radius: 12px;
            box-shadow: 0 0 8px rgba(18,255,161,0.45), 0 0 4px rgba(0,0,0,0.35);
            cursor: pointer;
            transition: transform 0.12s, box-shadow 0.12s;
        }
        input[type=range]::-moz-range-thumb:active { transform: translateY(-1px) scale(1.05); box-shadow: 0 0 10px rgba(18,255,161,0.6); }

        /* Markers & Loop Range */
        .markers-container { position: relative; height: 10px; margin-top: 5px; width: calc(100% - 20px); margin: 0 10px; }
        .marker {
            position: absolute; width: 0; height: 0;
            border-left: 6px solid transparent; border-right: 6px solid transparent;
            border-bottom: 10px solid var(--neon-pink);
            transform: translateX(-50%); pointer-events: none;
        }
        
        /* The Loop Highlight Bar */
        #activeLoopRange {
            position: absolute;
            top: 20px; /* Raised further to avoid overlapping time labels */
            height: 8px;
            background: var(--neon-pink);
            opacity: 0;
            pointer-events: none;
            border-radius: 4px;
            transition: opacity 0.3s;
            box-shadow: 0 0 10px var(--neon-pink);
            z-index: 2; /* Below thumb, above track bg */
        }

        /* CONTROLS */
        .controls-mid {
            display: flex; justify-content: space-between; align-items: center; padding: 10px 20px;
        }
        .tempo-btn {
            background: radial-gradient(circle, #333, #111); border: 3px solid var(--neon-blue);
            width: 80px; height: 80px; border-radius: 50%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.4); cursor: pointer; user-select: none;
        }
        .tempo-btn:active { transform: scale(0.95); background: var(--neon-blue); color: #000; }
        .bpm-display { font-family: 'Fredoka One', cursive; font-size: 1.5rem; line-height: 1; }
        .bpm-label { font-size: 0.6rem; text-transform: uppercase; font-weight: 700; }

        .play-btn { font-size: 3rem; color: white; background: none; border: none; cursor: pointer; }
        
        .loop-btn {
            background: #222; border: 2px solid #555; color: #777;
            width: 70px; height: 50px; border-radius: 15px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; transition: all 0.3s ease;
        }
        .loop-btn.active { border-color: var(--neon-green); color: var(--neon-green); background: rgba(0, 255, 157, 0.1); }
        .loop-count { font-family: 'Fredoka One', cursive; font-size: 1.2rem; }
        .loop-label { font-size: 0.5rem; text-transform: uppercase; }

        /* MODE TABS */
        .mode-tabs {
            position: fixed;
            bottom: 15px;
            left: 0; right: 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 25;
        }
        .mode-tab {
            padding: 12px 18px;
            border-radius: 22px;
            border: 1px solid #2f3a5a;
            background: #0f162b;
            color: #e7ecff;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0,243,255,0.2);
        }
        .mode-tab.active {
            border-color: var(--neon-blue);
            background: linear-gradient(135deg, #1a223b, #111a33);
            color: #fff;
        }

        /* GRID */
        .grid-container {
            flex: 2.0;
            min-height: 0;
            padding: 12px 15px 18px 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-auto-rows: minmax(104px, 1fr);
            gap: 14px;
            overflow-y: auto;
            margin-bottom: 0px; /* minimal gap above bottom buttons */
        }
        .form-btn {
            border: none; border-radius: 12px; font-family: 'Fredoka One', cursive; font-size: 1rem;
            color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer; position: relative; transition: transform 0.1s;
        }
        .form-btn:active { transform: scale(0.90); }
        .form-btn.logged::after {
            content: '\f00c'; font-family: "Font Awesome 6 Free"; font-weight: 900;
            position: absolute; top: 5px; right: 5px; font-size: 0.8rem;
            color: white; background: rgba(0,0,0,0.3); border-radius: 50%;
            width: 15px; height: 15px; display: flex; align-items: center; justify-content: center;
        }

        .btn-intro { background: linear-gradient(135deg, #FF9966, #FF5E62); }
        .btn-verse { background: linear-gradient(135deg, #4facfe, #00f2fe); }
        .btn-chorus { background: linear-gradient(135deg, #f093fb, #f5576c); border: 2px solid white; }
        .btn-bridge { background: linear-gradient(135deg, #89f7fe, #66a6ff); }
        .btn-outro { background: linear-gradient(135deg, #a18cd1, #fbc2eb); }
        .btn-custom { background: linear-gradient(135deg, #43e97b, #38f9d7); color: #1a1a2e; }

        .edit-list {
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: calc(100vh - 260px);
            overflow-y: auto;
        }
        .edit-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #2f3a5a;
            border-radius: 12px;
            background: rgba(0,0,0,0.35);
            flex-wrap: wrap;
        }
        .swatch {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 8px rgba(0,0,0,0.3);
        }
        .edit-actions {
            margin-left: auto;
            display: flex; gap: 8px; flex-wrap: wrap;
        }
        .edit-actions button {
            border: none;
            border-radius: 8px;
            padding: 6px 10px;
            font-weight: 700;
            cursor: pointer;
        }
        .btn-edit { background: var(--neon-blue); color: #000; }
        .btn-delete { background: #ff5e62; color: #fff; }

        /* ADD/EDIT MODAL */
        .modal-backdrop {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center; justify-content: center;
            z-index: 50;
        }
        .modal-card {
            background: #111526;
            border: 1px solid #2a2f4d;
            border-radius: 16px;
            padding: 18px;
            width: 340px;
            max-width: calc(100% - 32px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.45);
        }
        .modal-card h3 {
            margin: 0 0 10px 0;
            font-family: 'Fredoka One', cursive;
            letter-spacing: 0.3px;
        }
        .modal-card label {
            font-size: 0.9rem; color: #cfd5ff;
        }
        .modal-card input[type="text"],
        .modal-card input[type="color"] {
            width: 100%;
            margin: 6px 0 12px 0;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #2f3a5a;
            background: #0a0f1f;
            color: #fff;
        }
        .modal-actions {
            display: flex; gap: 10px; margin-top: 10px;
        }
        .modal-actions button {
            flex: 1; padding: 10px 0;
            border-radius: 10px; border: none;
            font-weight: 800; cursor: pointer;
        }
        .modal-primary { background: var(--neon-green); color: #0a0a1a; }
        .modal-secondary { background: #1d243b; color: #d8e0ff; border: 1px solid #2f3a5a; }

        /* FORM DRAWER */
        .form-drawer {
            position: fixed;
            left: 0; right: 0;
            bottom: 70px;
            background: #0f162b;
            border-top: 1px solid #2f3a5a;
            border-left: 1px solid #1c2741;
            border-right: 1c2741;
            border-radius: 18px 18px 0 0;
            box-shadow: 0 -8px 24px rgba(0,0,0,0.45);
            height: 240px; /* fits buttons */
            transition: height 0.25s ease, transform 0.25s ease;
            overflow: hidden;
            z-index: 40; /* above header so handle stays clickable */
        }
        .form-drawer.open {
            height: calc(100vh - 160px);
        }
        .drawer-handle {
            width: 60px; height: 6px; border-radius: 3px;
            background: #2f3a5a;
            margin: 8px auto 8px auto;
            cursor: pointer;
            position: relative;
            z-index: 45;
        }
        .drawer-content {
            height: calc(100% - 22px);
            overflow-y: auto;
            padding: 8px 10px 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #editListWrapper {
            flex: 1;
            overflow-y: auto;
        }
        /* keep buttons same size when drawer opens */
        #editGrid .form-btn { flex: 1 1 auto; }
        #editGrid { flex: 0 0 auto; }
        #editGrid {
            max-height: 220px;
            overflow-y: auto;
            padding: 8px 10px 12px 10px;
            grid-auto-rows: minmax(72px, 1fr);
            gap: 10px;
        }
        #editListWrapper {
            flex: 1;
            overflow-y: auto;
            min-height: 180px;
        }

        /* AUTH FLOATING BUTTON & MODAL */
        .auth-fab {
            position: fixed;
            bottom: 18px; right: 18px;
            width: 56px; height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            color: #0a0a1a;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 18px rgba(0, 243, 255, 0.5);
            border: 2px solid #111;
            cursor: pointer;
            z-index: 80;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }
        .form-btn.clicked {
            transform: scale(0.97);
            box-shadow: 0 0 12px rgba(255,255,255,0.35);
        }

        /* Lead sheet */
        .lead-container {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 12px 15px 80px 15px;
            overflow-y: auto;
        }
        .lead-container.active { display: flex; }
        .lead-card {
            border: 1px solid #2f3a5a;
            border-radius: 14px;
            padding: 12px;
            background: rgba(0,0,0,0.25);
        }
        .lead-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 800;
            margin-bottom: 8px;
            color: #e7ecff;
        }
        .lead-staff {
            background: #0b1326;
            border: 1px solid #1f2f4f;
            border-radius: 10px;
            padding: 8px;
        }
        .lead-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 8px 0;
            align-items: center;
        }
        .lead-controls select,
        .lead-controls button {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid #2f3a5a;
            background: #0f162b;
            color: #e7ecff;
            font-weight: 700;
        }
        .lead-controls button {
            background: var(--neon-blue);
            color: #000;
            border: none;
            cursor: pointer;
        }
        .auth-fab:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(189, 0, 255, 0.55); }
        .auth-fab:active { transform: scale(0.96); }

        .auth-modal-backdrop {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.65);
            backdrop-filter: blur(4px);
            display: none;
            align-items: center; justify-content: center;
            z-index: 40;
        }
        .auth-modal {
            background: #111526;
            border: 1px solid #2a2f4d;
            border-radius: 16px;
            padding: 18px;
            width: 320px;
            max-width: calc(100% - 32px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.45);
        }
        .auth-modal h3 {
            margin: 0 0 10px 0;
            font-family: 'Fredoka One', cursive;
            letter-spacing: 0.3px;
        }
        .auth-modal label {
            font-size: 0.85rem;
            color: #cfd5ff;
        }
        .auth-modal input {
            width: 100%;
            margin: 6px 0 12px 0;
            padding: 9px 10px;
            border-radius: 10px;
            border: 1px solid #2f3a5a;
            background: #0a0f1f;
            color: #fff;
        }
        .auth-row {
            display: flex; gap: 8px; margin-top: 6px;
        }
        .auth-modal button {
            flex: 1;
            padding: 10px 0;
            border: none;
            border-radius: 10px;
            font-weight: 800;
            cursor: pointer;
        }
        .auth-primary { background: var(--neon-green); color: #0a0a1a; }
        .auth-secondary { background: #1d243b; color: #d8e0ff; border: 1px solid #2f3a5a; }
        .auth-links { margin-top: 10px; display: flex; justify-content: space-between; font-size: 0.85rem; color: #7ea7ff; cursor: pointer; }
    </style>
</head>
<body>

    <div class="auth-gate" id="authGate">
        <div class="auth-gate-card">
            <h2 id="authGateTitle">Sign in</h2>
            <label for="gateEmail">Email</label>
            <input type="email" id="gateEmail" placeholder="you@example.com">
            <label for="gatePassword">Password</label>
            <input type="password" id="gatePassword" placeholder="••••••••">
            <div class="auth-gate-actions">
                <button class="secondary" type="button" id="authGateToggle">Need an account?</button>
                <button class="primary" type="button" id="authGateSubmit">Sign in</button>
            </div>
            <div class="link-row">
                <span id="authGateReset">Reset password</span>
                <span id="authGateStatus"></span>
            </div>
        </div>
    </div>

    <div id="appShell">
    <div class="app-header">
        <div class="logo-badge">J</div>
        <span class="header-email" id="authStateText">Signed out</span>
    </div>
    <div class="actions-stack" id="actionsStack" style="display:none;">
        <!-- legacy inline add form hidden now that Add Song modal exists -->
    </div>
        <div class="sheet-actions" id="songBar" style="align-items:center; gap:6px; margin-top:6px; font-size: 0.9rem; font-weight: 800;">
        <select id="videoSelect" class="fancy-select" style="min-width:180px; flex:1;">
            <option value="">Saved songs…</option>
        </select>
        <button class="secondary" id="addSongBtn" type="button">Add Song</button>
        <button class="secondary" id="editViewBtn" type="button" style="display:none;">Edit</button>
    </div>
    <div class="tempo-row" id="tempoRow">
        <span id="practiceBpm" class="tempo-pill">Tempo: --</span>
        <button class="tempo-btn hidden" id="tapBtn" type="button" onclick="handleTap()">Tap tempo</button>
        <span id="editBpm" class="tempo-pill hidden">Logged: --</span>
    </div>

    <div class="timeline-container">
        <audio id="audioPlayer" preload="auto" style="display:none"></audio>
        <div class="time-row">
            <span class="time-label" id="currentTimeLabel">0:00</span>
            <span class="time-label" id="durationLabel">0:00</span>
        </div>
        <div id="activeLoopRange"></div>
        <input type="range" min="0" max="100" value="0" id="videoTimeline">
        <div class="markers-container" id="markersArea"></div>
    </div>

    <div class="controls-mid">
        <button class="play-btn" onclick="togglePlay()">
            <i class="fas fa-play-circle" id="playIcon"></i>
        </button>
        <div class="loop-btn" id="loopBtn" onclick="toggleLoop()">
            <span class="loop-count" id="loopText"><i class="fas fa-ban"></i></span>
            <span class="loop-label">Loops</span>
        </div>
    </div>

    <div class="grid-container" id="practiceGrid"></div>

    <div class="mode-tabs">
        <button class="mode-tab active" id="tabPractice">Practice</button>
        <button class="mode-tab" id="tabEdit">Edit</button>
        <button class="mode-tab" id="tabLead">Lead</button>
    </div>

    <div class="form-drawer" id="formDrawer">
        <div class="drawer-handle" id="drawerHandle"></div>
        <div class="drawer-content">
            <div class="grid-container" id="editGrid"></div>
            <div class="edit-list hidden" id="editListWrapper">
                <div id="editList" class="edit-list"></div>
            </div>
        </div>
    </div>
    <div class="lead-container" id="leadContainer"></div>

    <div class="auth-fab" id="authFab" title="Account">
        <i class="fas fa-user-astronaut"></i>
    </div>
    <div class="auth-modal-backdrop" id="authModal">
        <div class="auth-modal">
            <h3>Account</h3>
            <label for="authEmail">Email</label>
            <input type="email" id="authEmail" placeholder="you@example.com">
            <label for="authPassword">Password</label>
            <input type="password" id="authPassword" placeholder="••••••••">
            <div class="auth-row">
                <button class="auth-secondary" type="button" onclick="closeAuthModal()">Close</button>
                <button class="auth-primary" type="button" onclick="handleSignIn()">Sign In</button>
            </div>
            <div class="auth-links">
                <span onclick="handleReset()">Reset password</span>
                <span onclick="handleRegister()">Create account</span>
            </div>
            <div class="auth-row" style="margin-top:10px;">
                <button class="secondary" type="button" onclick="handleSignOut()">Sign out</button>
            </div>
        </div>
    </div>
    <div class="modal-backdrop" id="formModal">
        <div class="modal-card">
            <h3 id="formModalTitle">Add Form</h3>
            <label for="formNameInput">Name</label>
            <input type="text" id="formNameInput" placeholder="Section name">
            <label for="formColorInput">Color</label>
            <input type="color" id="formColorInput" value="#ff6b6b">
            <div class="modal-actions">
                <button class="modal-secondary" type="button" onclick="closeFormModal()">Cancel</button>
                <button class="modal-primary" type="button" onclick="saveFormModal()">Save</button>
            </div>
        </div>
    </div>
    <div class="modal-backdrop" id="sectionModal">
        <div class="modal-card">
            <h3 id="sectionModalTitle">Edit Section</h3>
            <label for="sectionTypeSelect">Type</label>
            <select id="sectionTypeSelect" class="fancy-select"></select>
            <label for="sectionLabelInput">Label (optional)</label>
            <input type="text" id="sectionLabelInput" placeholder="e.g., Breakdown">
            <label for="sectionStartInput">Start time (mm:ss or seconds)</label>
            <input type="text" id="sectionStartInput" placeholder="0:00">
            <label for="sectionColorInput">Color</label>
            <input type="color" id="sectionColorInput" value="#4facfe">
            <div class="modal-row" style="margin: 6px 0; color: #d8e0ff; font-weight: 700;">
                <span id="sectionEndLabel">End: --:--</span>
            </div>
            <div class="modal-actions">
                <button class="modal-secondary" type="button" onclick="closeSectionModal()">Cancel</button>
                <button class="modal-primary" type="button" onclick="saveSectionModal()">Save</button>
            </div>
            <div class="modal-actions">
                <button class="btn-delete" type="button" onclick="deleteSectionModal()">Delete</button>
            </div>
        </div>
    </div>
    <div class="modal-backdrop" id="addSongModal">
        <div class="modal-card">
            <h3>Add Song</h3>
            <label for="newSongNameInput">Song name</label>
            <input type="text" id="newSongNameInput" placeholder="Song name">
            <label for="newSongArtistInput">Artist</label>
            <input type="text" id="newSongArtistInput" placeholder="Artist">
            <label for="newSongFileInput">Choose MP3</label>
            <input type="file" id="newSongFileInput" accept="audio/mpeg">
            <div class="modal-actions">
                <button class="modal-secondary" type="button" onclick="closeAddSongModal()">Cancel</button>
                <button class="modal-primary" type="button" onclick="saveNewSong()">Save</button>
            </div>
        </div>
    </div>
    </div> <!-- end appShell -->

    <script>
        // --- CONFIGURE SUPABASE HERE ---
        const SUPABASE_URL = 'https://ckunukizucqngibnfwcn.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNrdW51a2l6dWNxbmdpYm5md2NuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM4MzYxNjksImV4cCI6MjA3OTQxMjE2OX0.PYbmARvtxkb086RFitejG7almxGWpmSgJfVk0pB1i8I';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        var player;
        var videoDuration = 0;
        var updateTimer;
        
        // --- LOOP STATE ---
        // 0=Off, 1=1x, 2=2x, 3=4x, 4=Inf
        let loopSetting = 0; 
        let activeSection = null; // { start: 10, end: 20, remainingLoops: 2 }
        let savedSections = {}; // { 'btn-intro': { start, end, label, note } }
        let pendingMarkers = [];
        let currentSongId = null;
        let currentVideoMeta = {}; // { bpm, note }
        let authGateMode = 'signin'; // 'signin' | 'signup'

        const appShell = document.getElementById('appShell');
        const authGate = document.getElementById('authGate');
        const gateEmail = document.getElementById('gateEmail');
        const gatePassword = document.getElementById('gatePassword');
        const authGateSubmit = document.getElementById('authGateSubmit');
        const authGateToggle = document.getElementById('authGateToggle');
        const authGateTitle = document.getElementById('authGateTitle');
        const authGateStatus = document.getElementById('authGateStatus');
        const authGateReset = document.getElementById('authGateReset');
        const sheetStatus = null;
        const sheetStatusText = { textContent: '' };
        const songNameInput = document.getElementById('songNameInput');
        const songArtistInput = document.getElementById('songArtistInput');
        const videoSelect = document.getElementById('videoSelect');
        const audioFileInput = document.getElementById('audioFileInput');
        const authFab = document.getElementById('authFab');
        const authModal = document.getElementById('authModal');
        const authEmail = document.getElementById('authEmail');
        const authPassword = document.getElementById('authPassword');
        const authStateText = document.getElementById('authStateText');
        const authOpenBtn = document.getElementById('authOpenBtn');
        const authSignOutBtn = document.getElementById('authSignOutBtn');
        const bpmDisplay = document.getElementById('bpmDisplay');
        const currentTimeLabel = document.getElementById('currentTimeLabel');
        const durationLabel = document.getElementById('durationLabel');
        const timeline = document.getElementById('videoTimeline');
        const loopRangeBar = document.getElementById('activeLoopRange');
        const playButton = document.querySelector('.play-btn');
        const practiceGrid = document.getElementById('practiceGrid');
        const editGrid = document.getElementById('editGrid');
        const editList = document.getElementById('editList');
        const tabPractice = document.getElementById('tabPractice');
        const tabEdit = document.getElementById('tabEdit');
        const tabLead = document.getElementById('tabLead');
        const formModal = document.getElementById('formModal');
        const formNameInput = document.getElementById('formNameInput');
        const formColorInput = document.getElementById('formColorInput');
        const editViewBtn = document.getElementById('editViewBtn');
        const practiceBpm = document.getElementById('practiceBpm');
        const editBpm = document.getElementById('editBpm');
        const tapBtn = document.getElementById('tapBtn');
        const formDrawer = document.getElementById('formDrawer');
        const drawerHandle = document.getElementById('drawerHandle');
        const editListWrapper = document.getElementById('editListWrapper');
        const sectionModal = document.getElementById('sectionModal');
        const sectionTypeSelect = document.getElementById('sectionTypeSelect');
        const sectionStartInput = document.getElementById('sectionStartInput');
        const sectionEndLabel = document.getElementById('sectionEndLabel');
        const sectionColorInput = document.getElementById('sectionColorInput');
        const sectionLabelInput = document.getElementById('sectionLabelInput');
        const addSongBtn = document.getElementById('addSongBtn');
        const addSongModal = document.getElementById('addSongModal');
        const newSongNameInput = document.getElementById('newSongNameInput');
        const newSongArtistInput = document.getElementById('newSongArtistInput');
        const newSongFileInput = document.getElementById('newSongFileInput');
        const leadContainer = document.getElementById('leadContainer');
        const actionsStack = document.getElementById('actionsStack');
        const loopBtn = document.getElementById('loopBtn');
        const loopText = document.getElementById('loopText');
        let editingFormId = null;
        let formsMeta = {}; // {buttonId: {label, color}}
        let drawerOpen = false;
        let currentMode = 'practice';
        let creatingNewSection = false;
        let drawerTouchStartY = null;
        let drawerTouchOpen = false;
        let staffNotesCache = {}; // {sectionId: [{keys,duration}]}
        function updateSectionUIVisibility() {
            const hasSections = Object.keys(savedSections).length > 0;
            if (practiceGrid) {
                if (currentMode === 'practice') {
                    const showGrid = !!currentSongId && hasSections;
                    practiceGrid.classList.toggle('hidden', !showGrid);
                } else {
                    practiceGrid.classList.add('hidden');
                }
            }
            if (editListWrapper) {
                const showList = (currentMode === 'edit') && drawerOpen && hasSections;
                editListWrapper.classList.toggle('hidden', !showList);
            }
        }
        const TYPE_OPTIONS = ['Intro','Verse','Pre-Ch','Chorus','Bridge','Solo','Outro','Custom'];
        const BASE_FORMS = [
            { id: 'btn-intro', label: 'Intro' },
            { id: 'btn-verse', label: 'Verse' },
            { id: 'btn-pre', label: 'Pre-Ch' },
            { id: 'btn-chorus', label: 'Chorus' },
            { id: 'btn-bridge', label: 'Bridge' },
            { id: 'btn-solo', label: 'Solo' },
            { id: 'btn-outro', label: 'Outro' },
            { id: 'btn-custom', label: 'Custom' },
        ];
        const COLOR_MAP = {
            'btn-intro': '#f9a8d4',
            'btn-verse': '#7dd3fc',
            'btn-pre': '#fbbf24',
            'btn-chorus': '#fb7185',
            'btn-bridge': '#93c5fd',
            'btn-solo': '#c084fc',
            'btn-outro': '#a5b4fc',
            'btn-custom': '#34d399'
        };
        const TYPE_TO_BASE = {
            'Intro': 'btn-intro',
            'Verse': 'btn-verse',
            'Pre-Ch': 'btn-pre',
            'Chorus': 'btn-chorus',
            'Bridge': 'btn-bridge',
            'Solo': 'btn-solo',
            'Outro': 'btn-outro',
            'Custom': 'btn-custom'
        };
        let editingSectionId = null;

        function setSheetStatus(state, text) {
            if (!sheetStatus || !sheetStatusText) return;
            sheetStatus.classList.remove('error', 'ready');
            if (state === 'ready') sheetStatus.classList.add('ready');
            if (state === 'error') sheetStatus.classList.add('error');
            sheetStatusText.textContent = text;
        }

        function setControlsEnabled(enabled) {
            const disabledClass = 'controls-disabled';
            if (timeline) {
                timeline.disabled = !enabled;
                timeline.classList.toggle(disabledClass, !enabled);
            }
            const tc = document.querySelector('.timeline-container');
            if (tc) tc.classList.toggle(disabledClass, !enabled);
            if (playButton) playButton.classList.toggle(disabledClass, !enabled);
            if (typeof loopBtn !== 'undefined' && loopBtn) loopBtn.classList.toggle(disabledClass, !enabled);
        }

        function slugify(text) {
            return (text || '').toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'custom';
        }

        function baseType(label) {
            if (!label) return 'Custom';
            return label.replace(/\s+\d+$/, '').trim();
        }

        function colorForMeta(id, meta) {
            const type = baseType(meta?.label || id);
            const baseKey = TYPE_TO_BASE[type] || id;
            return COLOR_MAP[baseKey] || meta?.color || defaultColors(id);
        }

        function parseTimeInput(val) {
            if (!val) return null;
            if (val.includes(':')) {
                const parts = val.split(':').map(Number);
                if (parts.some(isNaN)) return null;
                if (parts.length === 2) return parts[0] * 60 + parts[1];
                if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        }

        function defaultColors(id) {
            const palette = ['#FF9966', '#4facfe', '#f093fb', '#89f7fe', '#a18cd1', '#43e97b', '#fbc2eb', '#66a6ff', '#38f9d7'];
            return palette[Math.abs(hashCode(id)) % palette.length];
        }

        function hashCode(str) {
            let h = 0;
            for (let i = 0; i < str.length; i++) h = ((h << 5) - h) + str.charCodeAt(i) | 0;
            return h;
        }

        function normalizeSongId(raw) {
            const parsed = (raw || '').trim();
            return parsed || null;
        }

        function makeSongId(name, artist) {
            const base = `${(name || '').trim()}-${(artist || '').trim()}`.toLowerCase();
            return base.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || null;
        }

        function showAppShell() { appShell.classList.remove('hidden'); authGate.classList.add('hidden'); }
        function showAuthGate() { appShell.classList.add('hidden'); authGate.classList.remove('hidden'); }

        function setAuthGateMode(mode) {
            authGateMode = mode;
            authGateTitle.textContent = mode === 'signin' ? 'Sign in' : 'Create account';
            authGateSubmit.textContent = mode === 'signin' ? 'Sign in' : 'Sign up';
            authGateToggle.textContent = mode === 'signin' ? 'Need an account?' : 'Have an account?';
            authGateStatus.textContent = '';
        }

        function formatTime(sec) {
            if (!Number.isFinite(sec) || sec < 0) return '0:00';
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function setAudioSource(url) {
            if (!player) return;
            player.src = url || '';
            try { player.load(); } catch (e) {}
            setControlsEnabled(!!url);
            if (!url) {
                if (currentTimeLabel) currentTimeLabel.textContent = '0:00';
                if (durationLabel) durationLabel.textContent = '0:00';
                if (timeline) timeline.value = 0;
            }
        }

        function setAudioAndSave(url) {
            setAudioSource(url);
            if (player && player.play) {
                try { player.play(); } catch (e) {}
            }
            setControlsEnabled(!!url);
            return saveVideoMeta({ audioUrl: url });
        }

        function parseNoteMeta(noteVal) {
            if (!noteVal) return {};
            try {
                const parsed = JSON.parse(noteVal);
                return typeof parsed === 'object' && parsed !== null ? parsed : {};
            } catch (e) {
                return {};
            }
        }

        function getStaffNotes(sectionId) {
            if (staffNotesCache[sectionId]) return staffNotesCache[sectionId];
            const entry = savedSections[sectionId];
            if (!entry) return [];
            const meta = parseNoteMeta(entry.note);
            const notes = Array.isArray(meta.staffNotes) ? meta.staffNotes : [];
            staffNotesCache[sectionId] = notes;
            return notes;
        }

        function setStaffNotes(sectionId, notes) {
            const entry = savedSections[sectionId];
            if (!entry) return;
            const meta = parseNoteMeta(entry.note);
            meta.staffNotes = notes;
            entry.note = JSON.stringify(meta);
            staffNotesCache[sectionId] = notes;
        }

        function syncFormsMetaFromSections() {
            formsMeta = {};
            Object.entries(savedSections).forEach(([id, entry]) => {
                const noteMeta = parseNoteMeta(entry.note);
                const label = noteMeta.label || entry.label || id;
                const color = colorForMeta(id, { label, color: noteMeta.color });
                formsMeta[id] = { label, color };
            });
        }

        function renderGrids() {
            // Practice: show saved forms for the selected song (content persists; visibility handled elsewhere)
            if (practiceGrid) {
                practiceGrid.innerHTML = '';
                Object.entries(formsMeta).forEach(([id, meta]) => {
                    const btn = document.createElement('button');
                    btn.className = 'form-btn';
                    btn.style.background = colorForMeta(id, meta);
                    btn.id = id;
                    btn.textContent = meta.label;
                    btn.onclick = () => handleSectionClick(id, meta.label);
                    practiceGrid.appendChild(btn);
                });
            }
            // Edit: fixed base set (one per type) with distinct colors (content persists; visibility handled elsewhere)
            if (editGrid) {
                editGrid.innerHTML = '';
                BASE_FORMS.forEach(base => {
                    const btn = document.createElement('button');
                    btn.className = 'form-btn';
                    btn.style.background = COLOR_MAP[base.id] || defaultColors(base.id);
                    btn.id = base.id;
                    btn.textContent = base.label;
                    btn.onclick = () => handleSectionClick(base.id, base.label);
                    editGrid.appendChild(btn);
                });
            }
        }

        function computeNumberedSections() {
            const arr = Object.entries(savedSections).map(([id, entry]) => {
                const meta = formsMeta[id] || { label: entry.label || id, color: defaultColors(id) };
                const type = baseType(meta.label || entry.label || id);
                return {
                    id,
                    type,
                    start: Number(entry.start) || 0,
                    end: Number.isFinite(entry.end) ? entry.end : calculateEndTime(entry.start),
                    color: meta.color
                };
            });
            arr.sort((a, b) => a.start - b.start);
            const counters = {};
            arr.forEach(item => {
                counters[item.type] = (counters[item.type] || 0) + 1;
                item.displayLabel = `${item.type} ${counters[item.type]}`;
            });
            return arr;
        }

        async function updateSectionType(id, newType, newColor=null, newLabel=null) {
            if (!formsMeta[id]) return;
            if (newColor) formsMeta[id].color = newColor;
            formsMeta[id].label = newLabel || newType;
            if (savedSections[id]) {
                savedSections[id].label = newLabel || newType;
                const noteMeta = parseNoteMeta(savedSections[id].note);
                const colorToSave = newColor || noteMeta.color || formsMeta[id].color || defaultColors(id);
                savedSections[id].note = JSON.stringify({ ...noteMeta, label: (newLabel || newType), color: colorToSave });
                savedSections[id].color = colorToSave;
                formsMeta[id].color = colorToSave;
                await saveSection(id, savedSections[id]);
            }
            renderGrids();
            renderEditList();
        }

        async function updateSectionStart(id, val, newColor=null) {
            const secs = parseTimeInput(val);
            if (secs === null || !savedSections[id]) return;
            savedSections[id].start = secs;
            if (newColor) {
                const noteMeta = parseNoteMeta(savedSections[id].note);
                const colorToSave = newColor || noteMeta.color || defaultColors(id);
                savedSections[id].note = JSON.stringify({ ...noteMeta, color: colorToSave, label: savedSections[id].label });
                savedSections[id].color = colorToSave;
                if (formsMeta[id]) formsMeta[id].color = colorToSave;
            }
            await saveSection(id, savedSections[id]);
            renderEditList();
        }

        function openSectionModal(id) {
            const entry = savedSections[id];
            if (!entry) return;
            editingSectionId = id;
            const numbered = computeNumberedSections();
            const match = numbered.find(n => n.id === id);
            const type = match ? match.type : baseType(entry.label);
            const endVal = match ? match.end : calculateEndTime(entry.start);
            const colorVal = (formsMeta[id]?.color) || defaultColors(id);

            sectionModal.style.display = 'flex';
            sectionModalTitle.textContent = match ? match.displayLabel : 'Edit Section';

            sectionTypeSelect.innerHTML = '';
            TYPE_OPTIONS.forEach(opt => {
                const o = document.createElement('option');
                o.value = opt;
                o.textContent = opt;
                if (opt === type) o.selected = true;
                sectionTypeSelect.appendChild(o);
            });
            sectionStartInput.value = formatTime(entry.start || 0);
            sectionEndLabel.textContent = 'End: ' + formatTime(endVal);
            if (sectionColorInput) sectionColorInput.value = colorVal;
        }

        async function saveSectionModal() {
            if (!editingSectionId) return;
            const typeVal = sectionTypeSelect.value;
            const labelVal = (sectionLabelInput?.value?.trim()) || typeVal;
            const startVal = parseTimeInput(sectionStartInput.value);
            const colorVal = sectionColorInput ? sectionColorInput.value : defaultColors(editingSectionId);
            if (startVal === null) return;

            if (!savedSections[editingSectionId]) {
                // create new
                if (!formsMeta[editingSectionId]) formsMeta[editingSectionId] = { label: labelVal, color: colorVal };
                savedSections[editingSectionId] = {
                    start: startVal,
                    end: null,
                    label: labelVal,
                    note: JSON.stringify({ label: labelVal, color: colorVal })
                };
                formsMeta[editingSectionId] = { label: labelVal, color: colorVal };
                try {
                    await saveSection(editingSectionId, savedSections[editingSectionId]);
                } catch (err) {
                    console.warn('Save section failed', err);
                    setSheetStatus('error', 'Save failed');
                }
            } else {
                await updateSectionType(editingSectionId, typeVal, colorVal, labelVal);
                await updateSectionStart(editingSectionId, startVal, colorVal);
                savedSections[editingSectionId].label = labelVal;
                const noteMeta = parseNoteMeta(savedSections[editingSectionId].note);
                savedSections[editingSectionId].note = JSON.stringify({ ...noteMeta, label: labelVal, color: colorVal });
                formsMeta[editingSectionId].label = labelVal;
            }
            syncFormsMetaFromSections();
            renderGrids();
            renderEditList();
            updateSectionUIVisibility();
            closeSectionModal();
            creatingNewSection = false;
        }

        async function deleteSectionModal() {
            if (!editingSectionId) return;
            await deleteForm(editingSectionId, true);
            closeSectionModal();
        }

        function closeSectionModal() {
            editingSectionId = null;
            sectionModal.style.display = 'none';
        }

        function closeAddSongModal() {
            addSongModal.style.display = 'none';
        }

        async function saveNewSong() {
            const name = newSongNameInput.value.trim();
            const artist = newSongArtistInput.value.trim();
            const fileInput = newSongFileInput;
            if (!fileInput || !fileInput.files || !fileInput.files.length) {
                setSheetStatus('error', 'Pick an MP3');
                return;
            }
            // sync fields used by existing upload flow
            songNameInput.value = name;
            songArtistInput.value = artist;
            // temporarily swap file input reference
            await uploadAudioFile(fileInput);
            closeAddSongModal();
        }

        function renderEditList() {
            editList.innerHTML = '';
            const numbered = computeNumberedSections();
            if (!numbered.length) {
                const empty = document.createElement('div');
                empty.className = 'edit-item';
                empty.style.justifyContent = 'center';
                empty.textContent = 'No sections yet';
                editList.appendChild(empty);
            }
            numbered.forEach(item => {
                const row = document.createElement('div');
                row.className = 'edit-item';
                row.onclick = () => openSectionModal(item.id);

                const sw = document.createElement('div');
                sw.className = 'swatch';
                sw.style.background = colorForMeta(item.id, { label: item.displayLabel, color: item.color });

                const title = document.createElement('div');
                title.textContent = item.displayLabel;
                title.style.fontWeight = '800';

                const meta = document.createElement('div');
                meta.style.fontWeight = '700';
                meta.style.color = '#d8e0ff';
                meta.textContent = `${baseType(item.displayLabel)} • ${formatTime(item.start)} → ${formatTime(item.end)}`;

                row.appendChild(sw);
                row.appendChild(title);
                row.appendChild(meta);
                editList.appendChild(row);
            });

        }

        function renderStaff(sectionId) {
            if (typeof Vex === 'undefined' || !Vex.Flow) return;
            const target = document.getElementById(`staff-${sectionId}`);
            if (!target) return;
            target.innerHTML = '';
            const notes = getStaffNotes(sectionId);
            const VF = Vex.Flow;
            const renderer = new VF.Renderer(target, VF.Renderer.Backends.SVG);
            renderer.resize(320, 120);
            const context = renderer.getContext();
            const stave = new VF.Stave(10, 20, 300);
            stave.addClef("treble");
            stave.setContext(context).draw();
            if (!notes.length) return;
            const vfNotes = notes.map(n => new VF.StaveNote({ clef: "treble", keys: n.keys, duration: n.duration }));
            const voice = new VF.Voice({ num_beats: vfNotes.length, beat_value: 4 });
            voice.addTickables(vfNotes);
            const formatter = new VF.Formatter().joinVoices([voice]).format([voice], 260);
            voice.draw(context, stave);
        }

        function renderLeadSheet() {
            if (!leadContainer) return;
            if (typeof Vex === 'undefined' || !Vex.Flow) {
                leadContainer.innerHTML = '';
                const warn = document.createElement('div');
                warn.className = 'lead-card';
                warn.textContent = 'Staff renderer unavailable (VexFlow not loaded).';
                leadContainer.appendChild(warn);
                // try to load again on next render
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/vexflow@4.2.3/build/vexflow-min.js';
                document.head.appendChild(script);
                return;
            }
            if (!leadContainer) return;
            leadContainer.innerHTML = '';
            const numbered = computeNumberedSections();
            if (!numbered.length) {
                const empty = document.createElement('div');
                empty.className = 'lead-card';
                empty.textContent = 'No sections yet';
                leadContainer.appendChild(empty);
                return;
            }
            numbered.forEach(item => {
                const card = document.createElement('div');
                card.className = 'lead-card';
                const header = document.createElement('div');
                header.className = 'lead-header';
                header.textContent = item.displayLabel;
                const timeSpan = document.createElement('span');
                timeSpan.textContent = `${formatTime(item.start)} → ${formatTime(item.end)}`;
                header.appendChild(timeSpan);

                const controls = document.createElement('div');
                controls.className = 'lead-controls';
                const pitchSel = document.createElement('select');
                ['c/4','d/4','e/4','f/4','g/4','a/4','b/4','c/5','d/5','e/5','f/5','g/5','a/5','b/5'].forEach(p => {
                    const o = document.createElement('option');
                    o.value = p;
                    o.textContent = p.toUpperCase();
                    pitchSel.appendChild(o);
                });
                const durSel = document.createElement('select');
                [['q','Quarter'],['h','Half'],['w','Whole'],['8','8th']].forEach(([v,t]) => {
                    const o = document.createElement('option');
                    o.value = v;
                    o.textContent = t;
                    pitchSel.value === '8' ? '8th' : t;
                    durSel.appendChild(o);
                });
                const addBtn = document.createElement('button');
                addBtn.textContent = 'Add note';
                addBtn.onclick = async () => {
                    const notes = [...getStaffNotes(item.id)];
                    notes.push({ keys: [pitchSel.value], duration: durSel.value });
                    setStaffNotes(item.id, notes);
                    await saveSection(item.id, savedSections[item.id]);
                    renderStaff(item.id);
                };
                const clearBtn = document.createElement('button');
                clearBtn.textContent = 'Clear';
                clearBtn.onclick = async () => {
                    setStaffNotes(item.id, []);
                    await saveSection(item.id, savedSections[item.id]);
                    renderStaff(item.id);
                };
                controls.appendChild(pitchSel);
                controls.appendChild(durSel);
                controls.appendChild(addBtn);
                controls.appendChild(clearBtn);

                const staffDiv = document.createElement('div');
                staffDiv.className = 'lead-staff';
                staffDiv.id = `staff-${item.id}`;

                card.appendChild(header);
                card.appendChild(controls);
                card.appendChild(staffDiv);
                leadContainer.appendChild(card);

                renderStaff(item.id);
            });
        }

        async function saveVideoMeta(updates) {
            if (!currentSongId) return;
            const merged = { ...(currentVideoMeta || {}), ...updates };
            currentVideoMeta = merged;
            const note = JSON.stringify(merged);
            const { error } = await supabaseClient
                .from('videos')
                .upsert({
                    video_id: currentSongId,
                    note,
                    title: merged.title || currentVideoMeta.title || currentSongId,
                    audio_url: merged.audioUrl || null
                }, { onConflict: 'video_id' });
            if (error) throw error;
        }

        async function fetchVideoMeta(videoId) {
            const { data, error } = await supabaseClient
                .from('videos')
                .select('note,title,audio_url')
                .eq('video_id', videoId)
                .limit(1);
            if (error) {
                console.warn(error);
                return {};
            }
            const meta = parseNoteMeta(data?.[0]?.note);
            if (data?.[0]?.title) meta.title = data[0].title;
            if (!meta.audioUrl && data?.[0]?.audio_url) meta.audioUrl = data[0].audio_url;
            return meta;
        }

        function applyBpmFromMeta() {
            const val = currentVideoMeta && currentVideoMeta.bpm ? Math.round(currentVideoMeta.bpm) : null;
            if (practiceBpm) practiceBpm.textContent = 'Tempo: ' + (val ?? '--');
            if (editBpm) editBpm.textContent = 'Logged: ' + (val ?? '--');
        }

        async function loadVideoById(videoId) {
            const normalized = normalizeSongId(videoId);
            if (!normalized) {
                setSheetStatus('error', 'Pick a song');
                return;
            }
            currentSongId = normalized;
            currentVideoMeta = await fetchVideoMeta(normalized);
            applyBpmFromMeta();
            const url = currentVideoMeta.audioUrl || '';
            if (url) {
                setAudioSource(url);
                setControlsEnabled(true);
            } else {
                setAudioSource('');
                setControlsEnabled(false);
                setSheetStatus('error', 'This song has no audio yet. Upload & Set an MP3.');
            }
            await loadSectionsForVideo(normalized);
            if (songNameInput) songNameInput.value = currentVideoMeta.title || normalized;
            if (songArtistInput) songArtistInput.value = currentVideoMeta.artist || '';
            setSheetStatus('ready', 'Song loaded');
        }

        async function saveSection(buttonId, entry) {
            if (!currentSongId) {
                setSheetStatus('error', 'Pick or upload a song first');
                return;
            }
            const meta = formsMeta[buttonId] || { label: entry.label || buttonId, color: defaultColors(buttonId) };
            const noteObj = parseNoteMeta(entry.note);
            noteObj.label = meta.label;
            noteObj.color = meta.color;
            const payload = {
                button_id: buttonId,
                label: meta.label || entry.label || buttonId,
                start_seconds: entry.start,
                end_seconds: entry.end ?? calculateEndTime(entry.start),
                note: JSON.stringify(noteObj),
                video_id: currentSongId
            };
            const { error } = await supabaseClient
                .from('sections')
                .upsert(payload, { onConflict: 'video_id,button_id' });
            if (error) throw error;
        }

        function applyVideoIdFromInput() {
            // deprecated in favor of upload flow
        }

        async function saveVideoId(videoId, title, artist) {
            setSheetStatus('loading', 'Saving song…');
            const normalized = normalizeSongId(videoId);
            if (!normalized) {
                setSheetStatus('error', 'Enter a Song ID');
                return;
            }
            const merged = { ...(currentVideoMeta || {}), artist: artist || '', title: title || normalized };
            const note = JSON.stringify(merged);
            const { error } = await supabaseClient
                .from('videos')
                .upsert({
                    video_id: normalized,
                    title: title || normalized,
                    note,
                    audio_url: merged.audioUrl || null
                }, { onConflict: 'video_id' });
            if (error) {
                console.warn(error);
                setSheetStatus('error', error.message);
            } else {
                setSheetStatus('ready', 'Song saved');
                refreshVideoListSelection(normalized);
            }
        }

        async function uploadAudioFile(fileInputOverride=null) {
            const fileInput = fileInputOverride || audioFileInput;
            const file = fileInput.files?.[0];
            if (!file) {
                setSheetStatus('error', 'Choose an MP3 file');
                return;
            }
            const songName = (songNameInput.value || '').trim();
            const songArtist = (songArtistInput.value || '').trim();
            const songId = makeSongId(songName, songArtist);
            if (!songId) {
                setSheetStatus('error', 'Enter song name & artist first');
                return;
            }
            currentSongId = songId;
            await saveVideoId(songId, songName, songArtist);
            const path = `${songId}/${Date.now()}-${file.name}`;
            setSheetStatus('loading', 'Uploading MP3…');
            const { error } = await supabaseClient.storage.from('audio').upload(path, file, { upsert: true });
            if (error) {
                console.warn(error);
                setSheetStatus('error', error.message || 'Upload failed (check bucket "audio")');
                return;
            }
            const { data } = supabaseClient.storage.from('audio').getPublicUrl(path);
            const publicUrl = data?.publicUrl;
            if (!publicUrl) {
                setSheetStatus('error', 'No public URL; check bucket policy');
                return;
            }
            setAudioAndSave(publicUrl).then(() => {
                songNameInput.value = songName;
                songArtistInput.value = songArtist;
                refreshVideoListSelection(songId);
                setSheetStatus('ready', 'Audio uploaded & saved');
            }).catch(err => {
                console.warn(err);
                setSheetStatus('error', 'Audio save failed');
            });
        }

        async function pushSectionsToSheet() {
            if (!currentSongId) {
                setSheetStatus('error', 'Pick or upload a song first');
                return;
            }
            const rows = Object.entries(savedSections).map(([buttonId, entry]) => ({
                button_id: buttonId,
                label: (formsMeta[buttonId]?.label) || entry.label || buttonId,
                start_seconds: entry.start,
                end_seconds: Number.isFinite(entry.end) ? entry.end : calculateEndTime(entry.start),
                note: entry.note || '',
                video_id: currentSongId
            }));
            if (!rows.length) {
                setSheetStatus('error', 'No sections to save');
                setTimeout(() => setSheetStatus('ready', 'Supabase synced'), 1200);
                return;
            }
            setSheetStatus('loading', 'Saving sections…');
            const { error } = await supabaseClient
                .from('sections')
                .upsert(rows, { onConflict: 'video_id,button_id' });
            if (error) {
                console.warn(error);
                setSheetStatus('error', error.message);
            } else {
                setSheetStatus('ready', 'Sections saved');
            }
        }

        async function loadSupabaseData() {
            setSheetStatus('loading', 'Loading data…');
            try {
                // Load song list
                const { data: vidRows, error: vidErr } = await supabaseClient
                    .from('videos')
                    .select('video_id,note,title,created_at')
                    .order('created_at', { ascending: false });
                if (vidErr) throw vidErr;

                populateVideoDropdown(vidRows || []);
                savedSections = {};
                pendingMarkers = [];
                flushMarkers();
                setControlsEnabled(false);
                syncFormsMetaFromSections();
                renderGrids();
                renderEditList();
                setSheetStatus('ready', 'Supabase synced');
            } catch (err) {
                console.warn(err);
                setSheetStatus('error', 'Load failed');
            }
        }

        function populateVideoDropdown(rows) {
            videoSelect.innerHTML = '<option value="">Saved songs…</option>';
            rows.forEach(row => {
                const meta = parseNoteMeta(row.note);
                const label = meta.artist ? `${row.title || row.video_id} — ${meta.artist}` : (row.title || row.video_id);
                const opt = document.createElement('option');
                opt.value = row.video_id;
                opt.textContent = label;
                videoSelect.appendChild(opt);
            });
            editViewBtn.style.display = 'none';
            videoSelect.value = '';
        }

        async function loadSectionsForVideo(videoId) {
            savedSections = {};
            pendingMarkers = [];
            document.querySelectorAll('.form-btn.logged').forEach(btn => btn.classList.remove('logged'));

            // Try sections for this video_id first
            const { data: secRows, error } = await supabaseClient
                .from('sections')
                .select('button_id,label,start_seconds,end_seconds,video_id,note')
                .eq('video_id', videoId)
                .order('start_seconds', { ascending: true });

            let rows = secRows || [];
            if (!rows.length) {
                // fallback to global sections without video_id
                const { data: fallbackRows, error: fbErr } = await supabaseClient
                    .from('sections')
                    .select('button_id,label,start_seconds,end_seconds,video_id,note')
                    .is('video_id', null)
                    .order('start_seconds', { ascending: true });
                if (fbErr) console.warn(fbErr);
                rows = fallbackRows || [];
            }

            rows.forEach(entry => {
                const { button_id, label, start_seconds, end_seconds, note } = entry;
                savedSections[button_id] = {
                    start: Number(start_seconds),
                    end: end_seconds !== null ? Number(end_seconds) : null,
                    label: label || button_id,
                    note: note || ''
                };
                queueMarker(Number(start_seconds));
            });

            flushMarkers();
            syncFormsMetaFromSections();
            renderGrids();
            renderEditList();
            updateSectionUIVisibility();
            renderLeadSheet();
            if (currentMode === 'edit') {
                setDrawer(true);
            }
        }

        async function refreshVideoListSelection(selectId) {
            const { data, error } = await supabaseClient
                .from('videos')
                .select('video_id,note,title,created_at')
                .order('created_at', { ascending: false });
            if (error) {
                console.warn(error);
                return;
            }
            populateVideoDropdown(data || []);
            if (selectId) videoSelect.value = selectId;
        }

        function queueMarker(time) {
            if (!Number.isFinite(time)) return;
            pendingMarkers.push(time);
        }

        function flushMarkers() {
            if (videoDuration <= 0) return;
            const area = document.getElementById('markersArea');
            area.innerHTML = '';
            const colors = ['#00ff9d', '#ff00cc', '#00f3ff', '#bd00ff'];
            const unique = Array.from(new Set(pendingMarkers)).sort((a, b) => a - b);
            unique.forEach(time => {
                const marker = document.createElement('div');
                marker.className = 'marker';
                const percent = (time / videoDuration) * 100;
                marker.style.left = percent + '%';
                marker.style.borderBottomColor = colors[Math.floor(Math.random() * colors.length)];
                area.appendChild(marker);
            });
        }

        function initAudioPlayer() {
            player = document.getElementById('audioPlayer');
            if (!player) return;
            player.addEventListener('loadedmetadata', onAudioLoaded);
            player.addEventListener('timeupdate', onAudioTimeUpdate);
            player.addEventListener('play', updatePlayIcon);
            player.addEventListener('pause', updatePlayIcon);
            setControlsEnabled(false);
        }

        function onAudioLoaded() {
            videoDuration = player.duration || 0;
            timeline.max = videoDuration || 100;
            flushMarkers();
            if (durationLabel) durationLabel.textContent = formatTime(videoDuration);
            setControlsEnabled(!!player.src);
        }

        function onAudioTimeUpdate() {
            const currentTime = player.currentTime || 0;
            timeline.value = currentTime;
            if (currentTimeLabel) currentTimeLabel.textContent = formatTime(currentTime);

            if(activeSection && loopSetting > 0 && videoDuration) {
                if (currentTime >= activeSection.end) {
                    if (activeSection.remainingLoops > 0 || loopSetting === 4) {
                        player.currentTime = activeSection.start;
                        if(loopSetting !== 4) activeSection.remainingLoops--;
                    } else {
                        activeSection = null;
                        player.pause();
                        loopRangeBar.style.opacity = 0;
                    }
                }
            }
        }

        function updatePlayIcon() {
            const icon = document.getElementById('playIcon');
            if (!icon) return;
            icon.className = player && !player.paused ? "fas fa-pause-circle" : "fas fa-play-circle";
        }

        timeline.addEventListener('input', function() {
            const time = Number(this.value);
            if (player) player.currentTime = time;
            activeSection = null;
            loopRangeBar.style.opacity = 0;
            if (currentTimeLabel) currentTimeLabel.textContent = formatTime(time);
        });

        // --- SECTION LOGIC ---

        async function handleSectionClick(btnId, label) {
            const btn = document.getElementById(btnId);
            const entry = savedSections[btnId];
            const currentTime = player && Number.isFinite(player.currentTime)
                ? player.currentTime
                : (timeline && Number.isFinite(Number(timeline.value)) ? Number(timeline.value) : 0);
            const meta = formsMeta[btnId] || { label, color: COLOR_MAP[btnId] || defaultColors(btnId) };

            // In EDIT mode: always log at current position (no playback jump)
            if (currentMode === 'edit') {
                if (btnId === 'btn-custom') {
                    if (player && !player.paused) player.pause();
                    creatingNewSection = true;
                    editingSectionId = `${btnId}-${Date.now()}`;
                    sectionModal.style.display = 'flex';
                    sectionModalTitle.textContent = 'Add Custom';
                    sectionTypeSelect.innerHTML = '';
                    TYPE_OPTIONS.forEach(opt => {
                        const o = document.createElement('option');
                        o.value = opt;
                        o.textContent = opt;
                        if (opt === 'Custom') o.selected = true;
                        sectionTypeSelect.appendChild(o);
                    });
                    sectionStartInput.value = formatTime(currentTime);
                    sectionEndLabel.textContent = 'End: --';
                    if (sectionColorInput) sectionColorInput.value = meta.color;
                    return;
                } else {
                    const baseId = btnId.split('-').slice(0,2).join('-');
                    const newId = `${baseId}-${Date.now()}`;
                    const color = meta.color || COLOR_MAP[baseId] || defaultColors(newId);
                    formsMeta[newId] = { label: meta.label, color };
                    savedSections[newId] = {
                        start: currentTime,
                        end: null,
                        label: meta.label,
                        note: JSON.stringify({ label: meta.label, color })
                    };
                    if (btn) {
                        btn.classList.add('clicked');
                        setTimeout(() => btn.classList.remove('clicked'), 180);
                    }
                    const saveId = newId;
                    queueMarker(currentTime);
                    flushMarkers();
                    try {
                        await saveSection(saveId, savedSections[saveId]);
                        syncFormsMetaFromSections();
                        renderGrids();
                        renderEditList();
                        updateSectionUIVisibility();
                        setSheetStatus('ready', 'Section saved');
                    } catch (err) {
                        console.warn(err);
                        setSheetStatus('error', 'Save failed');
                    }
                    return;
                }
            }

            // PRACTICE mode behaviour (play existing, log new)
            if (entry) {
                const startTime = entry.start;
                let endTime = Number.isFinite(entry.end) ? entry.end : calculateEndTime(startTime);
                if (!Number.isFinite(endTime) || endTime <= startTime) endTime = Math.min(startTime + 8, videoDuration || startTime + 8);
                
                let loops = 0;
                if(loopSetting === 1) loops = 0;
                if(loopSetting === 2) loops = 1;
                if(loopSetting === 3) loops = 3;
                
                activeSection = {
                    start: startTime,
                    end: endTime,
                    remainingLoops: loops
                };

                updateLoopRangeVisual(startTime, endTime);
                
                if (player && player.src) {
                    player.currentTime = startTime;
                    player.play();
                }

            } else {
                savedSections[btnId] = {
                    start: currentTime,
                    end: null,
                    label: meta.label,
                    note: JSON.stringify({ label: meta.label, color: meta.color })
                };
                if (btn) {
                    btn.classList.add('logged');
                    btn.classList.add('clicked');
                    setTimeout(() => btn.classList.remove('clicked'), 180);
                }
                queueMarker(currentTime);
                flushMarkers();
                try {
                    await saveSection(btnId, savedSections[btnId]);
                    syncFormsMetaFromSections();
                    renderGrids();
                    renderEditList();
                    updateSectionUIVisibility();
                    setSheetStatus('ready', 'Section saved');
                } catch (err) {
                    console.warn(err);
                    setSheetStatus('error', 'Save failed');
                }
            }
        }

        // Logic: End Time = Start time of the NEAREST NEXT marker
        function calculateEndTime(startTime) {
            const times = Object.values(savedSections)
                .map(entry => entry.start)
                .filter(num => Number.isFinite(num))
                .sort((a, b) => a - b);
            
            const index = times.indexOf(startTime);
            if (index > -1 && index < times.length - 1) {
                return times[index + 1];
            } else {
                return videoDuration || startTime;
            }
        }

        function updateLoopRangeVisual(start, end) {
            if (!videoDuration) return;
            const startPct = (start / videoDuration) * 100;
            const endPct = (end / videoDuration) * 100;
            const width = Math.max(endPct - startPct, 0);
            
            loopRangeBar.style.left = startPct + '%';
            loopRangeBar.style.width = width + '%';
            loopRangeBar.style.opacity = 1;
        }

        // --- CONTROLS ---
        function togglePlay() {
            if(!player) return;
            if (!player.src) {
                setSheetStatus('error', 'No audio loaded');
                return;
            }
            if (!player.paused) player.pause();
            else player.play();
        }

        let taps = [];
        async function handleTap() {
            const now = Date.now();
            if (taps.length > 0 && now - taps[taps.length - 1] > 2000) taps = [];
            taps.push(now);
            if (taps.length > 4) taps.shift();
            if (taps.length > 1) {
                const intervals = [];
                for (let i = 1; i < taps.length; i++) intervals.push(taps[i] - taps[i-1]);
                const avg = intervals.reduce((a, b) => a + b) / intervals.length;
                const bpm = Math.round(60000 / avg);
                currentVideoMeta = currentVideoMeta || {};
                currentVideoMeta.bpm = bpm;
                applyBpmFromMeta();
                try {
                    await saveVideoMeta({ bpm });
                } catch (err) {
                    console.warn('Save BPM failed', err);
                }
            }
        }

        function toggleLoop() {
            loopSetting++;
            if (loopSetting > 4) loopSetting = 0;
            loopBtn.classList.add('active');
            if (loopSetting===0) {
                loopText.innerHTML = '<i class="fas fa-ban"></i>';
                loopBtn.classList.remove('active');
            } else if (loopSetting===4) {
                loopText.innerHTML = '<i class="fas fa-infinity"></i>';
            } else {
                // 1=1x, 2=2x, 3=4x
                const counts = [0, 1, 2, 4];
                loopText.innerText = counts[loopSetting] + 'x';
            }
        }

        // --- MODE TOGGLE ---
        function setDrawer(open) {
            drawerOpen = open;
            if (!formDrawer) return;
            formDrawer.classList.toggle('open', !!open);
            if (editListWrapper) editListWrapper.classList.toggle('hidden', !open);
            if (editListWrapper) {
                if (open) editListWrapper.classList.remove('hidden');
                else editListWrapper.classList.add('hidden');
            }
        }

        function setMode(mode) {
            currentMode = mode;
            if (mode === 'practice') {
                tabPractice.classList.add('active');
                tabEdit.classList.remove('active');
                if (tabLead) tabLead.classList.remove('active');
                const showGrid = !!currentSongId && Object.keys(savedSections).length > 0;
                if (practiceGrid) practiceGrid.classList.toggle('hidden', !showGrid);
                if (editGrid) editGrid.classList.add('hidden');
                if (editListWrapper) editListWrapper.classList.add('hidden');
                if (leadContainer) leadContainer.classList.remove('active');
                actionsStack.classList.add('hidden');
                if (practiceBpm) practiceBpm.classList.remove('hidden');
                if (tapBtn) tapBtn.classList.add('hidden');
                if (editBpm) editBpm.classList.add('hidden');
                if (formDrawer) formDrawer.style.display = 'none';
                setDrawer(false);
            } else if (mode === 'edit') {
                tabPractice.classList.remove('active');
                tabEdit.classList.add('active');
                if (tabLead) tabLead.classList.remove('active');
                if (practiceGrid) practiceGrid.classList.add('hidden');
                if (editGrid) editGrid.classList.remove('hidden');
                if (editListWrapper) editListWrapper.classList.add('hidden'); // keep list hidden until user opens drawer
                if (leadContainer) leadContainer.classList.remove('active');
                actionsStack.classList.remove('hidden');
                if (practiceBpm) practiceBpm.classList.add('hidden');
                if (tapBtn) tapBtn.classList.remove('hidden');
                if (editBpm) editBpm.classList.remove('hidden');
                if (formDrawer) formDrawer.style.display = 'block';
                setDrawer(false); // start collapsed in Edit
            } else if (mode === 'lead') {
                tabPractice.classList.remove('active');
                tabEdit.classList.remove('active');
                if (tabLead) tabLead.classList.add('active');
                if (practiceGrid) practiceGrid.classList.add('hidden');
                if (editGrid) editGrid.classList.add('hidden');
                if (editListWrapper) editListWrapper.classList.add('hidden');
                if (formDrawer) formDrawer.style.display = 'none';
                actionsStack.classList.add('hidden');
                if (practiceBpm) practiceBpm.classList.remove('hidden');
                if (tapBtn) tapBtn.classList.add('hidden');
                if (editBpm) editBpm.classList.add('hidden');
                if (leadContainer) {
                    leadContainer.classList.add('active');
                    renderLeadSheet();
                }
                setDrawer(false);
            }
        }

        tabPractice.addEventListener('click', () => setMode('practice'));
        tabEdit.addEventListener('click', () => setMode('edit'));
        if (tabLead) tabLead.addEventListener('click', () => setMode('lead'));
        if (drawerHandle) drawerHandle.addEventListener('click', () => {
            const next = !drawerOpen;
            setDrawer(next);
            if (editListWrapper) editListWrapper.classList.toggle('hidden', !next && Object.keys(savedSections).length === 0);
        });
        if (addSongBtn) addSongBtn.addEventListener('click', () => {
            newSongNameInput.value = '';
            newSongArtistInput.value = '';
            if (newSongFileInput) newSongFileInput.value = '';
            addSongModal.style.display = 'flex';
        });
        function onDrawerTouchStart(e) {
            if (!e.touches || !e.touches.length) return;
            drawerTouchStartY = e.touches[0].clientY;
            drawerTouchOpen = drawerOpen;
        }
        function onDrawerTouchEnd(e) {
            if (drawerTouchStartY === null || !e.changedTouches || !e.changedTouches.length) return;
            const dy = e.changedTouches[0].clientY - drawerTouchStartY;
            if (dy < -25) setDrawer(true);
            else if (dy > 25) setDrawer(false);
            drawerTouchStartY = null;
        }
        if (drawerHandle) {
            drawerHandle.addEventListener('touchstart', onDrawerTouchStart);
            drawerHandle.addEventListener('touchend', onDrawerTouchEnd);
        }
        if (formDrawer) {
            formDrawer.addEventListener('touchstart', onDrawerTouchStart);
            formDrawer.addEventListener('touchend', onDrawerTouchEnd);
        }
        if (editViewBtn) editViewBtn.addEventListener('click', () => setMode('edit'));

        // --- MODAL ---
        function openFormModal(formId = null) {
            editingFormId = formId;
            if (formId && formsMeta[formId]) {
                formModalTitle.textContent = 'Edit Form';
                formNameInput.value = formsMeta[formId].label;
                formColorInput.value = formsMeta[formId].color;
            } else {
                formModalTitle.textContent = 'Add Form';
                formNameInput.value = '';
                formColorInput.value = '#ff6b6b';
            }
            formModal.style.display = 'flex';
        }

        function closeFormModal() {
            formModal.style.display = 'none';
            editingFormId = null;
        }

        async function deleteForm(id, skipConfirm = false) {
            if (!skipConfirm) {
                const ok = window.confirm('Delete this section?');
                if (!ok) return;
            }
            delete formsMeta[id];
            delete savedSections[id];
            if (currentSongId) {
                try {
                    await supabaseClient.from('sections').delete().eq('video_id', currentSongId).eq('button_id', id);
                } catch (err) {
                    console.warn('Delete failed', err);
                }
            }
            renderGrids();
            renderEditList();
        }

        async function saveFormModal() {
            const name = formNameInput.value.trim();
            if (!name) { setSheetStatus('error', 'Name required'); return; }
            const color = formColorInput.value || '#ff6b6b';
            const newId = editingFormId || ('btn-' + slugify(name));
            formsMeta[newId] = { label: name, color };
            if (!savedSections[newId]) {
                savedSections[newId] = { start: 0, end: null, label: name, note: JSON.stringify({ label: name, color }) };
                await saveSection(newId, savedSections[newId]);
            } else {
                // update label/color
                savedSections[newId].label = name;
                savedSections[newId].note = JSON.stringify({ ...(parseNoteMeta(savedSections[newId].note)), label: name, color });
                await saveSection(newId, savedSections[newId]);
            }
            renderGrids();
            renderEditList();
            closeFormModal();
        }

        // --- BOOT ---
        document.addEventListener('DOMContentLoaded', () => {
            initAudioPlayer();
            initAuthGate();
            setMode('practice');
            applyBpmFromMeta();
            if (practiceGrid) practiceGrid.classList.add('hidden');
            setControlsEnabled(false);
            if (editListWrapper) editListWrapper.classList.remove('hidden');
        });

        // --- AUTH UI ---
        function openAuthModal() { authModal.style.display = 'flex'; }
        function closeAuthModal() { authModal.style.display = 'none'; }
        authFab.addEventListener('click', openAuthModal);
        authModal.addEventListener('click', (e) => { if (e.target === authModal) closeAuthModal(); });
        if (authOpenBtn) authOpenBtn.addEventListener('click', openAuthModal);
        if (authSignOutBtn) authSignOutBtn.addEventListener('click', handleSignOut);

        function updateAuthUI(session) {
            if (session?.user) {
                authStateText.textContent = session.user.email || 'Signed in';
                if (authSignOutBtn) authSignOutBtn.style.display = 'inline-block';
                showAppShell();
            } else {
                authStateText.textContent = 'Signed out';
                if (authSignOutBtn) authSignOutBtn.style.display = 'none';
                showAuthGate();
            }
        }

        async function handleSignIn() {
            setSheetStatus('loading', 'Signing in…');
            const { error } = await supabaseClient.auth.signInWithPassword({
                email: authEmail.value,
                password: authPassword.value
            });
            if (error) {
                setSheetStatus('error', error.message);
            } else {
                setSheetStatus('ready', 'Signed in');
                closeAuthModal();
                loadSupabaseData();
            }
        }
        async function handleRegister() {
            setSheetStatus('loading', 'Registering…');
            const { error } = await supabaseClient.auth.signUp({
                email: authEmail.value,
                password: authPassword.value
            });
            if (error) setSheetStatus('error', error.message);
            else setSheetStatus('ready', 'Check email to confirm');
        }
        async function handleReset() {
            setSheetStatus('loading', 'Sending reset…');
            const { error } = await supabaseClient.auth.resetPasswordForEmail(authEmail.value, {
                redirectTo: window.location.origin
            });
            if (error) setSheetStatus('error', error.message);
            else setSheetStatus('ready', 'Reset email sent');
        }
        async function handleSignOut() {
            await supabaseClient.auth.signOut();
            updateAuthUI(null);
            setSheetStatus('ready', 'Signed out');
        }

        // --- AUTH GATE LOGIC ---
        authGateSubmit.addEventListener('click', handleAuthGateSubmit);
        authGateToggle.addEventListener('click', () => {
            setAuthGateMode(authGateMode === 'signin' ? 'signup' : 'signin');
        });
        authGateReset.addEventListener('click', async () => {
            authGateStatus.textContent = 'Sending reset…';
            const { error } = await supabaseClient.auth.resetPasswordForEmail(gateEmail.value, {
                redirectTo: window.location.origin
            });
            authGateStatus.textContent = error ? error.message : 'Reset email sent';
        });

        async function handleAuthGateSubmit() {
            authGateStatus.textContent = authGateMode === 'signin' ? 'Signing in…' : 'Creating…';
            if (authGateMode === 'signin') {
                const { error } = await supabaseClient.auth.signInWithPassword({
                    email: gateEmail.value,
                    password: gatePassword.value
                });
                authGateStatus.textContent = error ? error.message : 'Signed in';
            } else {
                const { error } = await supabaseClient.auth.signUp({
                    email: gateEmail.value,
                    password: gatePassword.value
                });
                authGateStatus.textContent = error ? error.message : 'Check email to confirm';
            }
        }

        async function initAuthGate() {
            setAuthGateMode('signin');
            const { data } = await supabaseClient.auth.getSession();
            const session = data?.session || null;
            updateAuthUI(session);
            if (session) {
                showAppShell();
                loadSupabaseData();
            } else {
                showAuthGate();
            }
        }

        supabaseClient.auth.onAuthStateChange((_event, session) => {
            updateAuthUI(session || null);
            if (session?.user) {
                showAppShell();
                loadSupabaseData();
            } else {
                showAuthGate();
            }
        });

        // Video dropdown change handler
        videoSelect.addEventListener('change', async (e) => {
            const vid = e.target.value;
            if (!vid) {
                editViewBtn.style.display = 'none';
                currentSongId = null;
                setControlsEnabled(false);
                if (practiceGrid) practiceGrid.classList.add('hidden');
                return;
            }
            editViewBtn.style.display = 'inline-block';
            await loadVideoById(vid);
            if (currentMode === 'edit') {
                setDrawer(true);
                if (editListWrapper) editListWrapper.classList.remove('hidden');
            }
            if (currentMode === 'practice') {
                const showGrid = !!currentSongId && Object.keys(savedSections).length > 0;
                if (practiceGrid) practiceGrid.classList.toggle('hidden', !showGrid);
            }
            updateSectionUIVisibility();
        });
    </script>
</body>
</html>

